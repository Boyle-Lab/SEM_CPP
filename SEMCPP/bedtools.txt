bedtools will be used for the intersect function which will be comparing the 
	read and mergefile to identify .
	
	e.g. - "./bin/bedtools intersect -a $readfile -b $mergefile -wa -u | sort | uniq > $bedfile"
	
The -a option used in declaring the first bed file to be compared just as -b
	denotes that there will be a second file to compare with.

-wa will tell bedtools to write the original entry in the readfile for each 
	overlap.
	
The -u option tells bedtools to only write the original in A once for each 
	found overlap.
	
Identifies chromosones based upon chromosone name and final position, so if the 
	first and third elements of a line match it will print the specific chromosone 
	data.
	
Bed format has at a minimum three fields of chromosone name, starting position, 
	and end position but can have nine additional fields.
	
Prints out unique chromosones which in our case would have to save them as part 
	of the struct but also be numerically/alphabetically sorted and checks again 
	repeats of lines.(Vector of strings most likely)
	
Actual sorting algorithm found in the intersectfile.cpp and the initialization of
	flags can be found in ContextIntersect.cpp file.
	
Change the arguments to variables or possibly a struct dedicated to running bedtools
	that are passed to the function bedtools (going to change bedtools into a 
	function format.

Must bypass FileRecordTypeChecker since it will be passed as a struct and for the function 
	to be used it must be a valid struct.

Will need to apply the same methods of isBedFormat in FileRecordTypeChecker to verify the 
	formatting is valid for Bed format. (line 253)

Will need to check the number of fields in the bed file to denote which method to use 
	(i.e. passesBed5 line 443 FileRecordTypeChecker)

Will bypass FileRecordManager checks unless a step to check for the struct is implemented 
	or if file is otherwise manipulated.

Files dealt with as a class in bedtools the class is Bed + (number of elements in bedfile) + 
	Interval.

The class described extends Bed3Interval which extends Record. In turn these are the files which
	disect the input bed file.

The disection of the files occurs in the SingleLineDelimTextFileReader and utilizes the get 
	field function. (e.g. in Bed#Interval.cpp line 26)

File Record Manager calls on the function to initialize and therefore get the values from the file.

The values seem to be stored in a class called Quickstring which also contains a function 
	for assigning values or more so pointers to be used to reference the values for each distinct 
	column element.

	-Quickstring has a private pointer called buffer
	-Buffer is a pointer which can be used as an array to access the variables in memory
	 through defference as well as be resized similar to a vector when additional fields 
	 are found or implemented such as when the initialization of elements in the bed formatting
	 are entered and additional fields are added due to the new traits of the inherited class.
	-In appending buffer the memcpy function of string is used and in this case is fed the destination
	 of buffer + an offset amount called currSize, the input values, as well as the input length of 
	 the data

*Learn more about pointers in order to fully understand how the value is being stored.

*What is sline and why is it being added to the start pos
	-sLine seems to be used in data retrieval from the files where it is a variable used to 
	 hold full lines when disecting the input file
	-Appears to be there to append the elements to _buffer with a length of endpos-startpos

Program path:
	bedtools.cpp ->  bedtoolsdriver.cpp -> gets context -> contextIntersect.cpp-> bedtoolsdriver.cpp ->
	-> gets tool -> tool directs to context file -> initialize IntersectFile.cpp -> bedtoolsdriver.cpp ->
	-> initialize RecordOutputManager.cpp -> IntersectFile.cpp findNext of hits -> processHits -> 
	-> cleanupHits -> finalizeCalculations -> giveFinalReport? -> bedtools.cpp -> return 0

*Investigate hits and RecordKeyVector
	-hits is a vector variable in nature containing the matching chromosones and is found using the next
	 function found in RecordKeyVector
	-RecordKeyVector first looks at the chromosones to test whether they are sorted and then calls the 
	 masterscan function which contains the comparison algorithm for chromosones
	-masterscan test to see if the database and cache are null for that index or if chromChange is 
	 true and if so it continues past i
	-else it scans the database for hits, skips if it hits the end of the database and advances until its 
	 ahead of the query and updates hits and cache as necessary

*Future tasks look into the output of bedtools and change to adding it to the struct in a type of vector
	-the giveFinalOutput function of intersectFile will remain as a virtual abstraction
	-outputs the data directly to the terminal as standard output to allow for unix style commands
	 to be used
	-will need to change all or the outputs from couts and prints to adding to the struct in the form of a 
	 2d vector of strings and name it intersections or bedtoolsOutput

*Find where final output is sent to the terminal
	-seems to use a function within quickstring.cpp called append, which adds the character value to outbuf
	-outbuf gets written out to stream through a function called flush which pushes the output held in outbuf 
	 to the terminal using fwrite
	-may change the flush function to define a variable within the struct with the values in which outbuf 
	 points to, minimizing the load of doing overhauls on calculations performed and other functions that 
	 currently use outbuf to send output to a file or stream (our case is stdout)
	-processhits ->printRecord(Record) ->printRecord(RecordKeyVector)->printRecord(RecordKeyVector, 
	 RecordKeyVector(which is null))
	-First time writing to stream occurs when the header gets outputted and calls the function flush()
	 at the very end which may be the only time if the "needsFlush" variable reads true
	-cleanup hits and finalize calculations appears to just be to close out variable and files from 
	 unnecessarily using memory

Plan on Implementation:
	-create a vector of string vectors in which contain the correct formatting of the output with "\t"
	 characters representing moving to the next element and newline characters representing a different
	 vector of strings (will be held in the struct)
	-Change the bedtools file to being a function which can be passed the struct
	-add the context variable and set it to intersect as well as a variable to tell the parsing method 
	 that it contains a struct and and to parse the elements accordingly
		-most likely will be a manipulated version of the bed file parsing function in order to 
		 trick the system into thinking it is a regular bed file 
	-change the flush function to be passed the struct and feed  the data pointed to by outbuf into the
	 vector contained in the struct to recieve the data

Btdriver work-
	*will need to change the testCmdArgs to either be bypassed or use to test that the vectors get defined
	*will need to change getContext to utilize the context variable given in the struct or directly define 
	 context in the btdriver as the struct variable

	*Will need to start with setProgram investigation and continue the conversion

Misc. notes-
	*Program_type refers to an enumerated variable that points to the actual name of the program
	*setProgram simply defines Program_type in a map
	*upcast is a function that  uses static casting to convert context to the contextIntersect
	*filenames are added within context intersect and must be adjusted to somehow include the data held within
	 the struct
	
	May need to develop bowtie_genome_map before altering the section that takes in filenames. This file is used
	as the read file for bedtools alongside the Dnase file for intersection. The part needed will have to pertain 
	to its location within the struct. I believe this is the bowtie output section but need to further investigate 
	how this vector is written.
	
	*the vector appears to be for the bed6+4, not sure on the output of bowtie though. Need to know the output of 
	 bowtie in order to know which file conversion functions to change

	*Need to fix issues with parsing as well as finding how to properly check for errors and compiling the functions 
	 without it searching for the included files or properly including them to allow for compilation.

	*to fix add "../(file directory)/

*Need to trace all variable in handle_b and address a replacement for them as well as change functionallity where needed